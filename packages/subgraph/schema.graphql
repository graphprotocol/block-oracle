type Payload @entity {
  id: ID!
  data: Bytes!
  submitter: String!
  valid: Boolean!
  "Optional error message in case the payload is invalid. Useful for debugging purposes"
  errorMessage: String
  messageBlocks: [MessageBlock!]! @derivedFrom(field: "payload")
}

type MessageBlock @entity {
  id: ID!
  data: Bytes!
  payload: Payload!
  messages: [Message!]! @derivedFrom(field: "block")
}

interface Message {
  id: ID!
  block: MessageBlock!
  "data is optional since it might be an empty message"
  data: Bytes
}

type SetBlockNumbersForEpochMessage implements Message @entity {
  id: ID!
  block: MessageBlock!
  data: Bytes
  merkleRoot: Bytes
  accelerations: [BigInt!]
  count: BigInt
}

type CorrectEpochsMessage implements Message @entity {
  id: ID!
  block: MessageBlock!
  data: Bytes
}

type UpdateVersionsMessage implements Message @entity {
  id: ID!
  block: MessageBlock!
  data: Bytes
  newVersion: Int!
  oldVersion: Int!
}

type ChangeOwnershipMessage implements Message @entity {
  id: ID!
  block: MessageBlock!
  data: Bytes
  newOwner: String!
  oldOwner: String!
}

type RegisterNetworksMessage implements Message @entity {
  id: ID!
  block: MessageBlock!
  data: Bytes
  removeCount: BigInt!
  addCount: BigInt!
  networksRemoved: [Network!]! @derivedFrom(field: "removedAt")
  networksAdded: [Network!]! @derivedFrom(field: "addedAt")
}

type Network @entity {
  id: ID! # chainID now
  #chainID: String!
  addedAt: RegisterNetworksMessage!
  removedAt: RegisterNetworksMessage
  blockNumbers: [NetworkEpochBlockNumber!]! @derivedFrom(field:"network")
  # Linked-list implementation for pop-and-swap
  "Next element on the linked-list implementation for networks. Used for list recreation"
  nextArrayElement: Network
  "Index number on the linked list"
  arrayIndex: Int
  # Link to global state to be able to recreate the list on query time for the GlobalState entity
  state: GlobalState
}

type GlobalState @entity {
  id: ID!
  networkCount: Int!
  activeNetworkCount: Int!
  networkArrayHead: Network
  latestValidEpoch: Epoch
  networks: [Network!]! @derivedFrom(field:"state")
  encodingVersion: Int!
  owner: String!
}

type Epoch @entity {
  id: ID!
  epochNumber: BigInt!
  blockNumbers: [NetworkEpochBlockNumber!]! @derivedFrom(field:"epoch")
}

type NetworkEpochBlockNumber @entity {
  id: ID!
  acceleration: BigInt!
  delta: BigInt!
  blockNumber: BigInt!
  epochNumber: BigInt! # We have to have this here to be able to sort by epochNumber
  network: Network!
  epoch: Epoch!
}
